// Translations Dictionary
const translations = {
    en: {
        nav_about: "About",
        nav_experience: "Experience",
        nav_portfolio: "Works",
        nav_research: "Research",
        nav_contact: "Contact",
        cover_title: "Product Design Student",
        about_text: "My focus lies in discovering the 'leverage points' hidden within user experiences, using minimal effort to drive maximum impact.",
        info_role_val: "Born in Anhui, China",
        info_edu_val: "Based in Fukuoka, Japan",
        info_nat_val: "M.A. Candidate at Kyushu University",
        experience_title: "Experience",
        exp_1_year: "2024 - Present",
        exp_1_org: "<a href='https://sodes.org/' target='_blank' class='text-white hover-opacity underline'>SodesLab</a>",
        exp_1_role: "Strategic Design Course_Kyushu University",
        exp_2_year: "2021 - 2024",
        exp_2_org: "Industrial Design",
        exp_2_role: "School of Industrial Design_Shandong University of Art & Design",
        exp_3_year: "2020 - 2021",
        exp_3_org: "Landscape Architecture",
        exp_3_role: "School of Architecture & Landscape Design_Shandong University of Art & Design",
        portfolio_title: "Recent Works",
        work_1_title: "OVO | AI Hardware Design",
        work_1_sub: "2026 / PRODUCT DESIGN",
        work_1_desc: "A shoulder-mounted AI work assistant that allows ultra-low voice interaction to protect privacy.",
        work_2_title: "MUSH | Slanted-Pillar Dredger",
        work_2_sub: "2024 / INDUSTRIAL DESIGN",
        work_2_desc: "Utilizes an innovative comparative stilt positioning pillar structure to achieve flexible mobile dredging in complex water areas.",
        work_3_title: "MA | Linked Vehicle Design",
        work_3_sub: "2025 / TRANSPORTATION DESIGN",
        work_3_desc: "Simulates a clip-like linking mechanism to enable the towing and connection of multiple utility vehicles.",
        work_4_title: "Other Works",
        work_4_sub: "AGILE DESIGN / SELF ITERATION",
        work_4_desc: "Product Design | Graphic Design | Signage Design | UI/UX Design | Landscape Design ...",
        research_main_title: "Master's Research: A Study on Co-creation Tools for Designing Interpretive Signage",
        research_main_sub: "Case Study of Fukuoka City Botanical Garden Greenhouse",
        research_main_desc: "Using the interpretive signage in the greenhouse of Fukuoka City Botanical Garden as a case study, this research clarifies existing issues and explores the ideal forms and specific tools for co-designing better interpretive signage.",
        research_1_title: "Signage Annotator: Image Coding and Annotation Tool",
        research_1_sub: "2026 / TOOL DEVELOPMENT",
        research_1_desc: "A co-creation tool for positioning, coding, annotating, and analyzing interpretive signage images based on the A/R/S interpretation design principles. It presents the current design characteristics of interpretive signage in various areas through analytical reports.",
        research_2_title: "Visual Analytics: Eye Tracking Tool",
        research_2_sub: "2026 / TOOL DEVELOPMENT",
        research_2_desc: "An eye-tracking tool implemented using a webcam. It uses heatmaps to understand users' attention concentration and visual flow when viewing interpretive signage.",
        research_3_title: "Participatory and Systemic Problem Extraction Framework",
        research_3_sub: "2025 / ACADEMIC PUBLICATION",
        research_3_desc: "Oral presentation at the Society for Art and Science 2025 Autumn Conference, introducing a framework for extracting co-creation issues prior to applying co-design.",
        nav_hobbies: "Hobbies",
        hobbies_travel: "Travel",
        hobbies_travel_desc: "Stimulating creativity with unfamiliar sights.",
        days_label: "DAYS IN JAPAN",
        places_label: "LOCATIONS VISITED",
        hobbies_photo: "Photography",
        hobbies_photo_desc: "Capturing asynchronous messages left by others.",
        contact_title: "Connect with Me",
        contact_desc: "Currently open for various design-related inquiries :)",
        email_label: "Email",
        social_label: "Social",
    },
    zh: {
        nav_about: "简介",
        nav_experience: "经历",
        nav_portfolio: "作品",
        nav_research: "研究",
        nav_contact: "联络",
        cover_title: "产品设计学生",
        about_text: "我专注于发现隐藏于用户体验中的'翘点',用最小的代价撬动最大的改变",

        info_role_val: "出身 中国安徽",
        info_edu_val: "现居 日本福冈",
        info_nat_val: "九州大学 硕士在读",
        experience_title: "个人经历",
        exp_1_year: "2024 至今",
        exp_1_org: "<a href='https://sodes.org/' target='_blank' class='text-white hover-opacity underline'>SodesLab</a>",
        exp_1_role: "ストラテジックデザインコース_九州大学",
        exp_2_year: "2021 - 2024",
        exp_2_org: "工业设计",
        exp_2_role: "工业设计学院_山东工艺美术学院",
        exp_3_year: "2020 - 2021",
        exp_3_org: "风景园林",
        exp_3_role: "建筑与景观设计学院_山东工艺美术学院",
        portfolio_title: "近期作品",
        work_1_title: "OVO | AI硬件设计",
        work_1_sub: "2026 / 产品设计",
        work_1_desc: "安装于肩上的AI工作助手,允许极小声的语音交互以保护隐私",
        work_2_title: "MUSH | 斜柱疏浚船",
        work_2_sub: "2024 / 工业设计",
        work_2_desc: "采用创新的高跷定位柱结构，实现在复杂水域的灵活移动疏浚工作",
        work_3_title: "MA | 链接载具设计",
        work_3_sub: "2025 / 交通工具设计",
        work_3_desc: "模拟夹子的链接方式,实现多载具的牵引与连接",
        work_4_title: "其他作品",
        work_4_sub: "敏捷设计 / 自我迭代",
        work_4_desc: "产品设计 | 平面设计 | 标识设计 | UI/UX设计 | 园林设计 ...",
        research_main_title: "修士研究：关于用于设计解说标识的共创工具的研究",
        research_main_sub: "以福冈市植物园温室区域为例",
        research_main_desc: "本研究以福冈市植物园温室区域设置的解说标识为案例，在明确其课题的同时，探讨为了设计出更好的解说标识，共创设计应有的方式与具体工具。",
        research_1_title: "Signage Annotator: 图像编码标注工具",
        research_1_sub: "2026 / 工具开发",
        research_1_desc: "基于A/R/S解说设计原则的解说标识图像的定位、编码、标注、分析共创工具。通过分析报告展示各区域解说标识的设计特征现状。",
        research_2_title: "Visual Analytics: 眼动追踪工具",
        research_2_sub: "2026 / 工具开发",
        research_2_desc: "利用网络摄像头实现的眼动追踪工具。通过热图了解用户的在观看解说标识时的注意力集中情况和视觉流向。",
        research_3_title: "参加型・システム型問題抽出フレームワーク",
        research_3_sub: "2025 / 学会发表",
        research_3_desc: "口头发表于艺术工学会2025年度秋季大会,介绍了用于共创设计前的共创问题提取框架。",
        nav_hobbies: "爱好",
        hobbies_travel: "旅行",
        hobbies_travel_desc: "用陌生的光景刺激创意",
        days_label: "在日天数",
        places_label: "去过的地点",
        hobbies_photo: "摄影",
        hobbies_photo_desc: "捕捉他人留下的异步讯息",
        contact_title: "与我发生交集",
        contact_desc: "目前可接受各类设计相关咨询 :)",
        email_label: "邮箱",
        social_label: "社交账号",
    },
    ja: {
        nav_about: "概要",
        nav_experience: "経歴",
        nav_portfolio: "作品集",
        nav_research: "研究",
        nav_contact: "連絡先",
        cover_title: "プロダクトデザイン学生",
        about_text: "ユーザー体験の中に隠された「レバレッジ・ポイント」を見極め、最小の労力で最大のインパクトを引き出すことに注力しています。",
        info_role_val: "出身：中国安徽省",
        info_edu_val: "現在地：日本福岡県",
        info_nat_val: "九州大学 修士課程在籍",
        experience_title: "経歴",
        exp_1_year: "2024 - 現在",
        exp_1_org: "<a href='https://sodes.org/' target='_blank' class='text-white hover-opacity underline'>SodesLab</a>",
        exp_1_role: "ストラテジックデザインコース_九州大学",
        exp_2_year: "2021 - 2024",
        exp_2_org: "インダストリアルデザイン",
        exp_2_role: "工業デザイン学部_山東工芸美術学院",
        exp_3_year: "2020 - 2021",
        exp_3_org: "ランドスケープデザイン",
        exp_3_role: "建築・景観デザイン学部_山東工芸美術学院",
        portfolio_title: "最近の作品",
        work_1_title: "OVO | AIハードウェアデザイン",
        work_1_sub: "2026 / プロダクトデザイン",
        work_1_desc: "肩に装着可能なAIアシスタント。極小声での音声操作によりプライバシーを保護。",
        work_2_title: "MUSH | 傾斜柱式浚渫船",
        work_2_sub: "2024 / インダストリアルデザイン",
        work_2_desc: "革新的な竹馬式位置決め柱構造を採用し、複雑な水域でも柔軟な移動と浚渫作業を実現。",
        work_3_title: "MA | 連結型車両デザイン",
        work_3_sub: "2025 / モビリティ・デザイン",
        work_3_desc: "クリップ状の連結機構を模倣し、複数の作業車両の牽引・接続を可能に。",
        work_4_title: "その他の作品",
        work_4_sub: "アジャイルデザイン / 自己イテレーション",
        work_4_desc: "プロダクトデザイン | グラフィックデザイン | サインデザイン | UI/UXデザイン | ランドスケープデザイン ...",
        research_main_title: "修士研究：解説サインのための共創ツールに関する研究",
        research_main_sub: "福岡市植物園温室エリアを事例として",
        research_main_desc: "本研究は、福岡市植物園の温室エリアに設置された解説サインを事例として、現状の課題を明らかにするとともに、より良い解説サインをデザインするために、共創デザインのあり方と具体的なツールについて探求するものです。",
        research_1_title: "Signage Annotator: 画像コーディング・アノテーションツール",
        research_1_sub: "2026 / ツール開発",
        research_1_desc: "A/R/S解説デザイン原則に基づく、解説サイン画像の位置決め・コーディング・アノテーション・分析のための共創ツール。分析レポートを通じて各エリアの解説サインのデザイン上の特徴を提示します。",
        research_2_title: "Visual Analytics: アイトラッキングツール",
        research_2_sub: "2026 / ツール開発",
        research_2_desc: "ウェブカメラを利用したアイトラッキングツール。ヒートマップを通じて、解説サインを見る際のユーザーの注意集中度や視線の動きを把握します。",
        research_3_title: "参加型・システム型問題抽出フレームワーク",
        research_3_sub: "2025 / 学会発表",
        research_3_desc: "芸術工学会2025年度秋季大会にて口頭発表。共創デザインを適用する前の共創課題抽出フレームワークについて紹介。",
        nav_hobbies: "趣味",
        hobbies_travel: "旅行",
        hobbies_travel_desc: "見知らぬ光景で創造性を刺激する。",
        days_label: "日本滞在日数",
        places_label: "訪れた場所",
        hobbies_photo: "写真",
        hobbies_photo_desc: "他者が残した非同期的なメッセージを捉える。",
        contact_title: "コンタクト",
        contact_desc: "様々なデザイン関連のご相談を受け付けております :)",
        email_label: "メール",
        social_label: "ソーシャル",
    }
};

document.addEventListener('DOMContentLoaded', () => {
    // Language Switcher Logic
    const langBtns = document.querySelectorAll('.lang-btn');
    const textElements = document.querySelectorAll('[data-i18n]');

    function setLanguage(lang) {
        // Update active button
        langBtns.forEach(btn => {
            if (btn.dataset.lang === lang) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        });

        // Update text texts with smooth fade
        textElements.forEach(el => {
            const key = el.dataset.i18n;
            if (translations[lang] && translations[lang][key]) {
                // Quick fade out
                el.style.opacity = '0';
                setTimeout(() => {
                    el.innerHTML = translations[lang][key];
                    // Fade back in
                    el.style.opacity = '1';
                }, 200); // match roughly CSS transition if any, or just brief delay
            }
        });

        // Update document lang
        document.documentElement.lang = lang;
    }

    // Setup transition for smooth language changing
    textElements.forEach(el => {
        el.style.transition = 'opacity 0.3s ease';
    });

    // Event Listeners for lang buttons
    langBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            setLanguage(btn.dataset.lang);
        });
    });

    // Reveal Animations on Scroll
    const revealElements = document.querySelectorAll('.reveal, .reveal-item');
    const revealOnLoad = document.querySelectorAll('.reveal-on-load');

    // Trigger initial load animations
    setLanguage('en');

    setTimeout(() => {
        const bgCanvas = document.getElementById('bg-canvas');
        if (bgCanvas) {
            bgCanvas.classList.remove('zoomed-intro');
        }

        // Wait for the red line wave to shrink before revealing texts
        setTimeout(() => {
            revealOnLoad.forEach(el => el.classList.add('visible'));
        }, 1200);

    }, 50);

    // Days in Japan Counter Logic
    let counterStarted = false;
    const initCounters = () => {
        if (counterStarted) return;
        counterStarted = true;

        const arrivalDate = new Date('2024-09-25'); // User can change this explicitly
        const today = new Date();
        const diffTime = Math.abs(today - arrivalDate);
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

        const daysElement = document.getElementById('days-counter');
        if (!daysElement) return;

        // Simple counter animation
        let count = 0;
        const target = diffDays;
        const duration = 2000;
        const interval = 20;
        const step = Math.max(1, Math.ceil(target / (duration / interval)));

        const timer = setInterval(() => {
            count += step;
            if (count >= target) {
                count = target;
                clearInterval(timer);
            }
            daysElement.textContent = count;
        }, interval);
    };

    // Intersection Observer for scroll reveal
    const revealObserver = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                entry.target.classList.add('visible');

                // If the hobbies section comes into view, start the counter
                if (entry.target.id === 'hobbies' || entry.target.closest('#hobbies')) {
                    initCounters();
                }
            }
        });
    }, {
        root: null,
        rootMargin: '0px 0px -10% 0px', // Trigger slightly before element comes into view
        threshold: 0.1
    });

    revealElements.forEach(el => {
        revealObserver.observe(el);
    });

    // Subdued Wave Background Animation
    const canvas = document.getElementById('bg-canvas');
    if (canvas) {
        const ctx = canvas.getContext('2d');
        let width, height;
        let time = 0;
        let targetScroll = window.scrollY;
        let currentScroll = window.scrollY;

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }

        window.addEventListener('resize', resize);
        window.addEventListener('scroll', () => {
            targetScroll = window.scrollY;
        });
        resize();

        function render() {
            // Smoothly interpolate scroll
            currentScroll += (targetScroll - currentScroll) * 0.05;
            const scrollVelocity = Math.abs(targetScroll - currentScroll);

            // Clear frame
            ctx.clearRect(0, 0, width, height);

            // Draw extremely faint, minimalist overlapping waves
            ctx.lineWidth = 1;

            const numWaves = 80;
            // Introduce a very slow breathing factor (0.8 to 1.2) for spacing and amplitude
            const breathe = Math.sin(time * 0.1) * 0.2 + 1.0;

            // Add extra breathing based on scroll velocity (moves faster/expands slightly when scrolling)
            const dynamicBreathe = breathe + Math.min(scrollVelocity * 0.005, 0.5);

            // Function to draw a wave group at a specific base Y offset
            const drawWaveGroup = (baseY, opacityMultiplier = 1) => {
                for (let j = 0; j < numWaves; j++) {
                    ctx.save();
                    ctx.beginPath();

                    if (j === Math.floor(numWaves / 2)) {
                        // Add a single red glowing line in the center
                        ctx.strokeStyle = `rgba(255, 60, 60, ${0.9 * opacityMultiplier})`;
                        ctx.shadowColor = `rgba(255, 60, 60, ${1 * opacityMultiplier})`;
                        ctx.shadowBlur = 12;
                        ctx.lineWidth = 1.5;
                    } else {
                        // Opacity fades smoothly at top and bottom to blend with background
                        // Increased base opacity by turning 0.05 into 0.12 so it's visible on smaller contrast screens
                        const normalizedJ = j / numWaves;
                        const opacity = Math.sin(normalizedJ * Math.PI) * 0.12 * opacityMultiplier;
                        ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
                    }

                    // Calculate actual Y position for this line
                    let yOffset = baseY + j * (height * 1.4 / numWaves) * breathe;

                    // Reduce point density for performance with 80 parallel lines
                    for (let i = 0; i <= width; i += 15) {
                        const wave1 = Math.sin(i * 0.003 + time * 0.4) * 80 * dynamicBreathe;
                        const wave2 = Math.sin(i * 0.001 - time * 0.2) * 120 * dynamicBreathe;

                        const x = i;
                        // Introduce a slight parabolic dip towards the center to make it look like a membrane
                        const distanceFromCenter = (i - width / 2) / (width / 2);
                        const dip = distanceFromCenter * distanceFromCenter * 50 * dynamicBreathe;

                        const y = yOffset + wave1 + wave2 + dip;

                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                    ctx.restore();
                }
            };

            // Group 1: The original wave group near the top
            // Moves slowly upwards as you scroll down
            const topGroupBaseY = (height * -0.2) - (currentScroll * 0.2);
            drawWaveGroup(topGroupBaseY, 1);

            // Group 2: The new wave group emerging from the bottom
            // Appears when scrolling deep into the page (e.g. past typical fold)
            // It will rise up from the bottom as you scroll further.
            const documentHeight = document.body.scrollHeight;
            const scrollRatio = currentScroll / (documentHeight - window.innerHeight);
            // It starts way below the screen, and moves up. We multiply currentScroll by 0.5 to make it appear faster
            const bottomGroupBaseY = (height * 1.5) - (currentScroll * 0.4);

            // Only draw second group if it's remotely close to or inside the viewport to save GPU
            if (bottomGroupBaseY < height + 400) {
                // Opacity fades in as it enters
                const entranceOpacity = Math.min(1, Math.max(0, (height + 200 - bottomGroupBaseY) / 400));
                drawWaveGroup(bottomGroupBaseY, entranceOpacity);
            }

            // Time advances faster if scrolling fast
            time += 0.01 + Math.min(scrollVelocity * 0.0005, 0.05);
            requestAnimationFrame(render);
        }

        render();
    }

    // Apple-style Horizontal Scroll Jacking (Desktop Only)
    let scrollJackers = [];

    function setupScrollJacking() {
        // Cleanup existing
        scrollJackers.forEach(jacker => {
            if (jacker.spacer.parentNode) {
                jacker.spacer.replaceWith(jacker.item);
            }
            jacker.item.style.position = '';
            jacker.item.style.top = '';
            jacker.track.style.transform = '';
            jacker.track.classList.remove('hijack-track');
        });
        scrollJackers = [];

        const workItems = document.querySelectorAll('.work-item');
        workItems.forEach(item => {
            const track = item.querySelector('.work-images-scroll, .work-images-grid-scroll');
            if (!track) return;

            // Calculate scrollable difference
            let maxTranslate = track.scrollWidth - track.clientWidth;

            if (maxTranslate <= 0) return;

            // Add padding at the end of scroll for better feel
            maxTranslate += 100;

            const spacer = document.createElement('div');
            spacer.className = 'work-item-spacer';
            // Spacer height includes the original item height plus the horizontal scroll distance
            spacer.style.height = `${item.offsetHeight + maxTranslate}px`;
            spacer.style.position = 'relative';

            item.parentNode.insertBefore(spacer, item);
            spacer.appendChild(item);

            // Center vertically
            const topOffset = Math.max(0, (window.innerHeight - item.offsetHeight) / 2);
            item.style.position = 'sticky';
            item.style.top = `${topOffset}px`;

            track.classList.add('hijack-track');

            scrollJackers.push({ spacer, item, track, maxTranslate, topOffset });
        });
    }

    // Initialize after layout is settled
    setTimeout(setupScrollJacking, 300);

    // De-bounce resize
    let resizeTimer;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(setupScrollJacking, 250);
    });

    // Update scroll
    window.addEventListener('scroll', () => {
        scrollJackers.forEach(jacker => {
            const rect = jacker.spacer.getBoundingClientRect();
            // When spacer's top reaches the sticky topOffset, pinning begins
            const startScrollY = jacker.topOffset;

            if (rect.top <= startScrollY) {
                const scrolledPast = startScrollY - rect.top;
                const translate = Math.max(0, Math.min(scrolledPast, jacker.maxTranslate));
                jacker.track.style.transform = `translateX(-${translate}px)`;
            } else {
                jacker.track.style.transform = `translateX(0px)`;
            }
        });
    }, { passive: true });
});
